I"D.<p>I’ve always wondered how c++ <code class="highlighter-rouge">std::map</code> works. Turns out its typically
implemented as a <em>Binary Search Tree (BST for short)</em>. Why a BST? The
most probable answer I can come up with, is how hashing is
implemented. How? Let’s see.</p>

<p>I’ll just go over string hashing as I don’t know the specifics about
how other data types are hashed. Basically, string hashing is a
process of turning any string into a unique integer that identifies
only that particular string. So, for example <em>hash(a) != hash(b)</em> for
any two strings <em>a</em> and <em>b</em> if <em>a != b</em>. In pactice, generating a
completely unique integer is not possible in c++ because of
limitations in integer sizes.</p>

<p>Generating a string hash is quite easy. Here’s how we’ll do it. There
are other ways to generate a hash.</p>

<p><em>hash(s) = { s[0] + s[1].p + s[2].p^2 + … + s[n-1].p^(n-1) } % MOD m</em></p>

<blockquote>
  <p><em>s</em> is the target string
<em>p</em> is represents power (we’ll use the
powers of a prime number) and, <em>m</em> denotes a number to MOD with and
<em>n</em> denotes the length of the string.</p>
</blockquote>

<h2 id="code">Code</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;bits/stdc++.h&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// NOTE: hashing only for lowercase letters</span>
<span class="c1">// In case of uppercase or other letters, set p = 53 and</span>
<span class="c1">// change the c-'a'+1 line to something suitable if necessary</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">compute_hash</span><span class="p">(</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">hash_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">p_pow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_pow</span><span class="p">)</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
		<span class="n">p_pow</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_pow</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">hash_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compute_hash</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compute_hash</span><span class="p">(</span><span class="s">"b"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compute_hash</span><span class="p">(</span><span class="s">"c"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compute_hash</span><span class="p">(</span><span class="s">"abc"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compute_hash</span><span class="p">(</span><span class="s">"abcd"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compute_hash</span><span class="p">(</span><span class="s">"sadfasdfasdfadsfasdfasdfasdfasdfas"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compute_hash</span><span class="p">(</span><span class="s">"sadfasdfasdfadsfasdfasdfasdfasdfaa"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
2
3
2946
122110
377376292
787694314
</code></pre></div></div>

<p>As can be seen, we’re doing <code class="highlighter-rouge">mod</code> with a certain integer <code class="highlighter-rouge">m</code> which is
a prime number. Selecting a prime for both <code class="highlighter-rouge">p</code> and <code class="highlighter-rouge">m</code> is important
for avoiding collisions (same hash for different strings) as much as
possible. If we didn’t mod with 10^9 + 9, it would be modded when
the multiplications overflowed the max integer size.</p>

<p>Now, coming to why <code class="highlighter-rouge">std::map</code> is implemented as a <code class="highlighter-rouge">BST</code>. It’s because
we can’t necessarily take an array of size 10^9 + 9 to store the
hashes for mapping as it will take a lot of memory and the compiler
will also complain about it. We need to come up with a data structure
which can store arbitrary integers and this is where <code class="highlighter-rouge">BST</code> comes in
handy. A simple implementation might look like this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">node</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">key</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">node</span> <span class="n">BST</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">compute_hash</span><span class="p">(</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>

<span class="n">string</span> <span class="nf">search</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">string</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">hash_of_k</span> <span class="o">=</span> <span class="n">compute_hash</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hash_of_k</span> <span class="n">exists</span> <span class="n">in</span> <span class="n">BST</span><span class="p">)</span> <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">string</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">hash_of_val</span> <span class="o">=</span> <span class="n">compute_hash</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hash_of_val</span> <span class="n">exists</span> <span class="n">in</span> <span class="n">BST</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">node</span> <span class="n">new_node</span><span class="p">;</span>
        <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">k</span> <span class="o">=</span> <span class="n">compute_hash</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">node</span><span class="p">;</span>
    
    <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">);</span>
    <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">"test"</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">search</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">search</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Obviously, the <code class="highlighter-rouge">std::map</code> is implemented in a more sophisticated way.
I’ve just thought about how it might be represented in a very simple
way.</p>
:ET