<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>String Hashing | sazid</title>

    <style>body{margin:40px auto;max-width:650px;line-height:1.6;font-size:18px;color:#444;padding:0 10px}h1,h2,h3{line-height:1.2}div.header h1{padding-top:0;padding-bottom:8px;margin-bottom:24px;font-size:18px;font-weight:400;border-bottom:1px solid}.header-menu{float:right}ul.pagination{list-style-type:none;text-align:center;padding:0}ul.pagination>li{padding:0 8px;display:inline-block}div.footer{border-top:1px solid;text-align:center}img{max-width:100%;max-height:100%;display:block;margin-left:auto;margin-right:auto}</style>

    
</head>

<body>
<div class="header">
    <h1>
        <a href="/">sazid</a>
        <div class="header-menu">
            <a href="/posts/">posts</a>
            <a href="/about/">about</a>
        </div>
    </h1>
</div>
<div id="content">

<header>
    <h1>String Hashing</h1>
    

<div class="post-meta">
    Date &#x5b;
    <time datetime="2019-01-22">Jan 22, 2019</time>
    &#x5d;
    Categories &#x5b;
    <a href="https://sazid.github.io/categories/programming/">programming</a>
    <a href="https://sazid.github.io/categories/algorithms/">algorithms</a>
    &#x5d;
    Tags &#x5b;
    <a href="https://sazid.github.io/tags/problem-solving/">problem-solving</a>
    <a href="https://sazid.github.io/tags/c&#43;&#43;/">c&#43;&#43;</a>
    &#x5d;
</div>
</header>
<article>
    <!-- MathJax -->

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<p>I&rsquo;ve always wondered how c++ <code>std::map</code> works. Turns out its
typically implemented as a
<strong>Binary Search Tree (BST for short)</strong>. Why a BST? The most probable
answer I can come up with, is how hashing is implemented. How?
Let&rsquo;s see.</p>

<p>I&rsquo;ll just go over string hashing as I don&rsquo;t know the specifics about
how other data types are hashed. Basically, string hashing is a
process of turning any string into a unique integer that identifies
only that particular string. So, for example $hash(a) \ne hash(b)$
for any two strings $a$ and $b$ if $a \ne b$. In practice, generating
a completely unique integer is not possible in c++ because of
limitations in integer sizes.</p>

<p>Generating a string hash is quite easy. Here&rsquo;s how we&rsquo;ll do it.
There are other ways to generate a hash.</p>

<p>$$
\text{hash}(s) = s[0] + s[1] \cdot p + s[2] \cdot p^2 + &hellip; + s[n-1] \cdot p^{n-1} \mod m
$$
$$
= \sum_{i=0}^{n-1} s[i] \cdot p^i \mod m
$$</p>

<p>Now, for the code:</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00f">#include</span> <span style="color:#00f">&lt;bits/stdc++.h&gt;</span><span style="color:#00f">
</span><span style="color:#00f"></span><span style="color:#00f">using</span> <span style="color:#00f">namespace</span> std;

<span style="color:#008000">// NOTE: hashing only for lowercase letters
</span><span style="color:#008000">// In case of uppercase or other letters, set p = 53 and
</span><span style="color:#008000">// change the c-&#39;a&#39;+1 line to something suitable if necessary
</span><span style="color:#008000"></span><span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span> compute_hash(string <span style="color:#00f">const</span>&amp; s) {
	<span style="color:#00f">const</span> <span style="color:#2b91af">int</span> p = 31;
	<span style="color:#00f">const</span> <span style="color:#2b91af">int</span> m = 1e9 + 9;
	<span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span> hash_value = 0;
	<span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span> p_pow = 1;
	<span style="color:#00f">for</span> (<span style="color:#2b91af">char</span> c : s) {
		hash_value = (hash_value + (c - <span style="color:#a31515">&#39;a&#39;</span> + 1) * p_pow) % m;
		p_pow = (p_pow * p) % m;
	}
	<span style="color:#00f">return</span> hash_value;
}

<span style="color:#2b91af">int</span> main() {
	cout &lt;&lt; compute_hash(<span style="color:#a31515">&#34;a&#34;</span>) &lt;&lt; endl;
	cout &lt;&lt; compute_hash(<span style="color:#a31515">&#34;b&#34;</span>) &lt;&lt; endl;
	cout &lt;&lt; compute_hash(<span style="color:#a31515">&#34;c&#34;</span>) &lt;&lt; endl;
	cout &lt;&lt; compute_hash(<span style="color:#a31515">&#34;abc&#34;</span>) &lt;&lt; endl;
	cout &lt;&lt; compute_hash(<span style="color:#a31515">&#34;abcd&#34;</span>) &lt;&lt; endl;
	cout &lt;&lt; compute_hash(<span style="color:#a31515">&#34;sadfasdfasdfadsfasdfasdfasdfasdfas&#34;</span>) &lt;&lt; endl;
	cout &lt;&lt; compute_hash(<span style="color:#a31515">&#34;sadfasdfasdfadsfasdfasdfasdfasdfaa&#34;</span>) &lt;&lt; endl;
	
	<span style="color:#00f">return</span> 0;
}
</code></pre></td></tr></table>
</div>
</div>
<p>Output:</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">1
2
3
2946
122110
377376292
787694314</pre></td></tr></table>
</div>
</div>
<p>As can be seen, we&rsquo;re doing <code>mod</code> with a certain integer <code>m</code> which is
a prime number. Selecting a prime for both <code>p</code> and <code>m</code> is important
for avoiding collisions (same hash for different strings) as much as
possible. If we didn&rsquo;t mod with $10^9 + 9$, it would be modded
when the multiplications overflowed the max integer size.</p>

<p>Now, coming to why <code>std::map</code> is implemented as a <code>BST</code>. It&rsquo;s because
we can&rsquo;t necessarily take an array of size $10^9 + 9$ to store the
hashes for mapping as it will take a lot of memory and the compiler
will also complain about it. We need to come up with a data structure
which can store arbitrary integers and this is where <code>BST</code> comes in
handy. A simple implementation might look like this:</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#00f">struct</span> node {
    <span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span> key;
    string value;
};

node BST[100];

<span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span> compute_hash(string <span style="color:#00f">const</span>&amp; s);

string search(node *n, string k) {
    <span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span> hash_of_k = compute_hash(k);
    <span style="color:#00f">if</span> (hash_of_k exists in BST) <span style="color:#00f">return</span> node-&gt;value;
    <span style="color:#00f">else</span> <span style="color:#00f">return</span> <span style="color:#a31515">&#34;&#34;</span>;
}

<span style="color:#2b91af">void</span> insert(node *n, string val) {
    <span style="color:#2b91af">long</span> <span style="color:#2b91af">long</span> hash_of_val = compute_hash(val);
    <span style="color:#00f">if</span> (hash_of_val exists in BST) {
        n-&gt;value = val;
    } <span style="color:#00f">else</span> {
        node new_node;
        new_node-&gt;k = compute_hash(val);
        new_node-&gt;value = val;
    }
}

<span style="color:#2b91af">int</span> main() {
    node *root = <span style="color:#00f">new</span> node;
    
    insert(root, <span style="color:#a31515">&#34;abc&#34;</span>);
    insert(root, <span style="color:#a31515">&#34;test&#34;</span>);

    cout &lt;&lt; search(root, <span style="color:#a31515">&#34;abc&#34;</span>) &lt;&lt; endl;
    cout &lt;&lt; search(root, <span style="color:#a31515">&#34;hello&#34;</span>) &lt;&lt; endl;
}
</code></pre></td></tr></table>
</div>
</div>
<p>Obviously, the <code>std::map</code> is implemented in a more sophisticated way.
I&rsquo;ve just thought about how it might be represented in a very
simple way.</p>

</article>


    </div>
<div class="footer">
    
    

    
    
    <div class="copyright">© 2019 — Mohammed Sazid Al Rashid — All rights reserved.</div>
    
</div>
</body>

</html>